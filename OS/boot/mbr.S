; 主引导程序
;功能：在屏幕上打印字符串"1 MBR",背景色为黑色，前景色为绿色
;-------------------------------------------------------

section MBR vstart=0x7c00

    ; 初始化段寄存器，BIOS通过jmp 0:0x7c00跳转到mbr，故此时cs的值为0
    mov ax, cs
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov fs, ax
    mov sp, 0x7c00 
    ; 这个时候 ds = es = ss = 0 栈指针指向MBR开始位置
    ; 0x7c00以下暂时是安全的区域，就把当作mbr的栈来用
    ; 初始化段寄存器结束


    ; 清屏 利用0x06号功能，上卷全部行，则可清屏。
    ; -----------------------------------------------------------
    ;INT 0x10   功能号:0x06	   功能描述:上卷窗口
    ;------------------------------------------------------
    ;输入：
    ;AH 功能号= 0x06
    ;AL = 上卷的行数(如果为0,表示全部)
    ;BH = 上卷行属性
    ;(CL,CH) = 窗口左上角的(X,Y)位置
    ;(DL,DH) = 窗口右下角的(X,Y)位置
    ;无返回值：
    mov ax, 0x600 ; 设置AH为06， 即功能号= 0x06, 上卷全部行数
    mov bx, 0x700
    mov cx, 0     ; 窗口左上角的(0,0)位置
    mov dx, 0x184f ;窗口右下角的(24,79)位置, 因为默认为80x25的VGA文本模式, 0x18=24, 0x4f=79
    int 0x10
    ; 清屏结束


    ;;;;;;;;;    下面这三行代码是获取光标位置    ;;;;;;;;;
    ;.get_cursor获取当前光标位置,在光标位置处打印字符.
    mov ah, 3   ; 输入: 3号子功能是获取光标位置,需要存入ah寄存器
    mov bh, 0   ; bh寄存器存储的是待获取光标的页号
    ; 输出: ch=光标开始行,cl=光标结束行
    ; dh=光标所在行号,dl=光标所在列号
    int 0x10
    ;;;;;;;;;    获取光标位置结束    ;;;;;;;;;;;;;;;;


    ;;;;;;;;;    往光标处打印字符串    ;;;;;;;;;;;
    ;还是用10h中断,不过这次是调用13号子功能打印字符串
    mov ax, message ;往ax写入字符串首地址
    mov bp, ax  ; bp和sp都是栈的有效地址(偏移地址)，默认的段是堆栈段，es:bp 为串首地址, es此时同cs一致，

    ; 光标位置要用到dx寄存器中内容,cx中的光标位置可忽略
    ; .get_cursor输出: ch=光标开始行,cl=光标结束行
    ; dh=光标所在行号,dl=光标所在列号
    mov cx, 5		; 显示字符串长度
    mov ax, 0x1301  ; 子功能号13是显示字符及属性,要存入ah寄存器,al设置写字符方式 al=01: 显示字符串,光标跟随移动
    mov bx, 0x2 ; bh存储要显示的页号,此处是第0页,bl中是字符属性, 属性黑底绿字(bl = 02h)
    int 0x10    ; 执行BIOS 0x10 号中断
    ;;;;;;;;;      打字字符串结束	 ;;;;;;;;;;;;;;;


    jmp $   ; 使程序悬停在此

    message db "1 MBR"
    times 510-($-$$) db 0 	;$本行指令的地址,$$是本section的起始地址, times伪指令，重复执行db 0 指令 510-($-$$)次
    db 0x55,0xaa 	;在最后写入魔数 0x55 0xaa

